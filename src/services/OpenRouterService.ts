import { Result, ok, err, tryAsync } from "../utils/result";
import { OpenRouterError, ConfigError } from "../utils/errors";
import { ConfigService } from "./ConfigService";
import { join } from "path";
import { LogService } from "./LogService";

export class OpenRouterService {
  static async generate(prompt: string, modelOverride?: string): Promise<Result<string, OpenRouterError | ConfigError>> {
    const interactionId = await LogService.logInfo("Iniciando geração com IA", { modelOverride });

    const configResult = await ConfigService.load();
    if (!configResult.ok) {
      const errorStr = `Falha ao ler configuração para OpenRouter: ${configResult.error.message}`;
      await LogService.logError("ConfigError", errorStr, interactionId);
      return err(new ConfigError(errorStr));
    }
    const config = configResult.value;
    if (!config.apiKey) {
      const errorStr = "API Key não configurada. Configure nas Configurações.";
      await LogService.logError("ConfigError", errorStr, interactionId);
      return err(new ConfigError(errorStr));
    }

    let defaultModel = "google/gemini-2.5-flash";
    try {
      const menusFile = Bun.file(join(process.cwd(), "config", "menus.json"));
      if (await menusFile.exists()) {
        const menusData = await menusFile.json();
        if (menusData.defaultModel) {
          defaultModel = menusData.defaultModel;
        }
      }
    } catch (e) {
      // Falha silenciosa para leitura de fallback
    }

    const modelName = modelOverride || config.model || defaultModel;

    const bodyPayload = {
      model: modelName,
      messages: [
        { role: "user", content: prompt }
      ]
    };
    await LogService.logRequest("OpenRouter API Request", bodyPayload, interactionId);

    const result = await tryAsync(async () => {
      const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${config.apiKey}`,
          "HTTP-Referer": "http://localhost:3000", // Optional, for OpenRouter rankings
          "X-Title": "Replication TUI", // Optional, for OpenRouter rankings
          "Content-Type": "application/json"
        },
        body: JSON.stringify(bodyPayload)
      });

      if (!response.ok) {
        const errorText = await response.text();
        await LogService.logError("OpenRouter HTTP Error", { status: response.status, response: errorText }, interactionId);
        throw new Error(`OpenRouter API error (${response.status}): ${errorText}`);
      }

      const data = await response.json();
      await LogService.logResponse("OpenRouter API Response", data, interactionId);

      if (!data.choices || data.choices.length === 0) {
        const errorStr = "No response generated by OpenRouter";
        await LogService.logError("OpenRouter Data Error", errorStr, interactionId);
        throw new Error(errorStr);
      }

      return data.choices[0].message.content;
    }, "OpenRouterService.generate");

    if (!result.ok) {
      await LogService.logError("tryAsync Error", result.error.message, interactionId);
      return err(new OpenRouterError(result.error.message));
    }

    return ok(result.value);
  }

  static async enhanceInstruction(instruction: string): Promise<Result<string, OpenRouterError | ConfigError>> {
    const prompt = `Melhore a seguinte instrução para um prompt de IA. Torne-a mais clara, direta e detalhada, preservando o objetivo original. Retorne APENAS a instrução melhorada. Instrução original: ${instruction}`;
    return this.generate(prompt);
  }
}
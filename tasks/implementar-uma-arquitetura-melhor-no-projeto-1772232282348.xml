```xml
<prompt version="1.0" name="Implementar uma arquitetura melhor no projeto ">
  <role>
    <persona>Um arquiteto de software sênior e engenheiro de refatoração, com foco em sistemas distribuídos e metodologias ágeis.</persona>
    <expertise>
      <item>Design de Arquitetura de Software (Clean Architecture, DDD, Microsserviços)</item>
      <item>Refatoração de Código (patterns, debt removal)</item>
      <item>Garantia de Escalabilidade e Manutenibilidade</item>
      <item>Melhores Práticas de Codificação e Testes</item>
      <item>Análise e Otimização de Performance</item>
    </expertise>
    <behavior>Você pensa de forma estruturada, documenta cada decisão arquitetural com justificativa clara, e entrega código production-ready, otimizado, testável e de fácil manutenção, priorizando a estabilidade e o desempenho do sistema.</behavior>
  </role>
  <generated_knowledge>
    <instruction>Antes de propor a refatoração e nova arquitetura, recupere e consolide internamente o seguinte conhecimento:</instruction>
    <knowledge_blocks>
      <block id="K1" topic="Padrões de Arquitetura">
        Conceitos de Clean Architecture, Domain-Driven Design (DDD), Modular Monolith, Service-Oriented Architecture (SOA), Microsserviços, Hexagonal Architecture. Padrões de design (Factory, Singleton, Repository, Strategy, Observer). Princípios SOLID.
      </block>
      <block id="K2" topic="Refatoração Segura">
        Técnicas de refatoração para introduzir testes, extrair módulos, simplificar lógica complexa, remover dependências cíclicas, e garantir que cada mudança mantenha o comportamento externo do sistema. Uso de ferramentas de análise estática.
      </block>
      <block id="K3" topic="Qualidade de Código">
        Métricas de complexidade ciclomática, coesão, acoplamento. Boas práticas para nomeclatura, comentários, legibilidade. Estratégias de testes unitários, de integração, e end-to-end. DevOps e CI/CD.
      </block>
      <block id="K4" topic="Escalabilidade e Manutenibilidade">
        Considerações sobre balanceamento de carga, caching, filas de mensagens, degradação graciosa. Estratégias para documentação de arquitetura, contratos de API, e processos de desenvolvimento.
      </block>
    </knowledge_blocks>
  </generated_knowledge>
  <few_shot_examples>
    <example id="E1" label="Sugestão de Refatoração de Módulo Acoplado">
      <input>Tenho um arquivo `main.js` com toda a lógica de um CRUD de usuários, validação, persistência e envio de email. Precisamos deixar isso mais organizado.</input>
      <output>
        ANÁLISE INICIAL: O `main.js` apresenta alto acoplamento e baixa coesão, dificultando testes e manutenção.
        PROPOSTA DE REFORMA:
        1. Separar as responsabilidades: Criar camadas de `Service` (lógica de negócio), `Repository` (persistência), `Controller` (interação API/UI) e `Notification` (envio de email).
        2. Injeção de Dependências: Usar um contêiner de DI para gerenciar as dependências entre as camadas, promovendo inversão de controle.
        3. Testes: Implementar testes unitários para cada camada e de integração para o fluxo completo.
        4. Estrutura de Pastas: Organizar em `src/modules/users/{controller, service, repository, tests}`.
        Impacto Esperado: Maior clareza na separação de responsabilidades, facilidade de manutenção e testabilidade, permitindo futuras extensões sem afetar outras partes do sistema.
      </output>
    </example>
    <example id="E2" label="Crítica a Código Vibe Coding com Solução">
      <input>O código atual possui funções com mais de 200 linhas, `if/else` aninhados e variáveis globais sem controle. Quais os problemas e como resolver?</input>
      <output>
        PROBLEMAS IDENTIFICADOS:
        - Funções longas: Dificultam a compreensão, manutenção e reutilização, além de violar o princípio de responsabilidade única.
        - `if/else` aninhados (Arrow Anti-Pattern): Aumenta a complexidade ciclomática, tornando o código difícil de testar e cheio de bugs.
        - Variáveis globais: Introduzem efeitos colaterais imprevisíveis e dificultam o controle do estado da aplicação.
        SOLUÇÕES PROPOSTAS:
        - Funções Longas: Quebrar em funções menores e mais específicas, cada uma com uma única responsabilidade (SRP).
        - `if/else` aninhados: Aplicar padrões como "Guarda Clausura", "Strategy Pattern" ou polimorfismo para achatar a estrutura condicional.
        - Variáveis Globais: Encapsulá-las em classes/módulos, passar como parâmetros ou usar gerencimento de estado para controlar seu acesso e modificação.
      </output>
    </example>
  </few_shot_examples>
  <chain_of_thought>
    <instruction>Antes de propor a refatoração e nova arquitetura, siga OBRIGATORIAMENTE estas etapas de raciocínio e exiba cada uma:</instruction>
    <steps>
      <step order="1">ANÁLISE DO ESTADO ATUAL: Avaliar o codebase existente para identificar pontos críticos: acoplamento, coesão, complexidade, duplicação, falta de testes, gargalos de performance, dependências cíclicas.</step>
      <step order="2">DEFINIÇÃO DE OBJETIVOS: Esclarecer as metas da refatoração (ex: escalabilidade, manutenibilidade, performance, segurança, deploy mais fácil). O que o "vibe coding" original impediu?</step>
      <step order="3">PROPOSTA DE ARQUITETURA: Desenhar uma arquitetura-alvo (ex: Clean Architecture, Microsserviços, Modular Monolith) baseada nos objetivos e análise atual, justificando a escolha e os trade-offs.</step>
      <step order="4">PLANO DE REFORMA (BIG-PICTURE): Elaborar um plano de alto nível, identificando as fases principais da refatoração: extração de módulos, introdução de testes, aplicação de padrões, separação de camadas. Listar mudanças estruturais chave.</step>
      <step order="5">RECOMENDAÇÕES DE IMPLEMENTAÇÃO: Detalhar diretrizes para a codificação: padrões de design, tratamento de erros, testes, documentação, CI/CD. Especificar as ferramentas e tecnologias a serem consideradas.</step>
      <step order="N">SÓ ENTÃO: Apresentar a solução completa e detalhada para a refatoração.</step>
    </steps>
  </chain_of_thought>
  <tree_of_thoughts>
    <instruction>Para as decisões abaixo, explore 3 abordagens, avalie prós/contras de cada uma e escolha a melhor justificando:</instruction>
    <decision_points>
      <decision id="D1" question="Qual o melhor estilo arquitetural para garantir escalabilidade e manutenibilidade para um projeto que começou em 'vibe coding'?">
        <branch id="B1">Microsserviços</branch>
        <branch id="B2">Monolito Modular</branch>
        <branch id="B3">Clean Architecture com Monolito Tradicional</branch>
        <evaluate>Qual oferece o melhor equilíbrio entre complexidade de gestão e benefício a longo prazo para um projeto que precisa primeiro de estabilidade e organização, considerando o histórico de "vibe coding"?</evaluate>
      </decision>
      <decision id="D2" question="Qual estratégia para introduzir testes em um codebase existente e sem testes é mais eficaz e segura?">
        <branch id="B1">Testes de ponta a ponta (E2E) primeiramente</branch>
        <branch id="B2">Focar em testes unitários para novas funcionalidades e refatorações pequenas</branch>
        <branch id="B3">A "Golden Master" (Snapshot Testing) para áreas críticas</branch>
        <evaluate>Qual abordagem minimiza o risco de quebrar algo existente, garante cobertura gradativa e permite refatoração segura?</evaluate>
      </decision>
    </decision_points>
  </tree_of_thoughts>
  <self_consistency>
    <instruction>Para a definição da estratégia de migração do código herdado para a nova arquitetura, gere 3 versões distintas internamente. Então compare:
      - Viabilidade de implementação incremental
      - Redução de risco durante a transição
      - Qualidade do resultado final
      Entregue SOMENTE a versão vencedora, explicando em 2 linhas por que venceu.
    </instruction>
  </self_consistency>
  <react_loop>
    <instruction>Para cada tarefa abaixo, execute o ciclo ReAct: Thought → Action → Observation → (repita se necessário) → Final Answer</instruction>
    <tasks>
      <task id="T1" name="Diagnóstico de Acoplamento e Coesão">
        <thought>Como identificar os módulos mais acoplados e menos coesos neste projeto de "vibe coding"?</thought>
        <action>Analisar a estrutura de importações/dependências, o tamanho das classes/funções e a quantidade de responsabilidades por componente.</action>
        <observation>Obter um mapa de calor de acoplamento/coesão para apresentar as áreas mais problemáticas.</observation>
        <action>Se não houver ferramentas de análise estática, simular manualmente com base em código-fonte ou realizar questionário técnico.</action>
        <final>Lista priorizada de módulos e componentes com alto acoplamento e baixa coesão, com justificativas.</final>
      </task>
      <task id="T2" name="Recomendação de Tecnologia para Novo Componente">
        <thought>Existe a necessidade de um novo componente de processamento de filas. Qual tecnologia devo recomendar para este contexto, considerando a nova arquitetura e a facilidade de manutenção?</thought>
        <action>Pesquisar as opções de message brokers (Kafka, RabbitMQ, SQS, etc.) com base nos requisitos de escalabilidade, durabilidade e facilidade de integração do projeto.</action>
        <observation>Comparar características, comunidade, curva de aprendizado e custos.</observation>
        <final>Recomendação da tecnologia de fila de mensagens mais adequada, com prós e contras sucintos.</final>
      </task>
    </tasks>
  </react_loop>
  <maieutic_prompting>
    <instruction>Antes de finalizar a implementação, responda e valide cada afirmação:</instruction>
    <validations>
      <validate claim="A nova arquitetura proposta garante que a lógica de negócio esteja completamente desacoplada da infraestrutura e da UI.">Justifique com exemplos de como o princípio da Inversão de Dependência (DIP) será aplicado e como as interfaces e implementações serão separadas, assegurando que o domínio não conhece as camadas externas.</validate>
      <validate claim="Todos os novos módulos ou módulos refatorados terão cobertura de teste adequada e serão facilmente testáveis.">Descreva a estratégia de testagem (unitários, integração), as ferramentas e frameworks a serem utilizados, e como a arquitetura facilita a criação de mocks/stubs e isolamento de dependências.</validate>
      <validate claim="O processo de deployment será mais simples e seguro após a refatoração, minimizando downtime e risco de regressões.">Explique como a modularização e a automação de CI/CD contribuirão para isso, incluindo estratégias de rollback e monitoramento pós-deploy.</validate>
    </validations>
  </maieutic_prompting>
  <task>
    <title>Refatoração Completa de Projeto de Vibe Coding para Arquitetura Escalável e Manutenível</title>
    <project_structure>
      <file path="src/domain/">Contém entidades, agregações, value objects, interfaces de repositório e serviços de domínio. Representa o núcleo do negócio, independente de frameworks.</file>
      <file path="src/application/">Contém casos de uso (use cases) que orquestram a lógica do domínio. Gerencia transações e coordena a interação com a infraestrutura.</file>
      <file path="src/infrastructure/">Implementações concretas de interfaces de repositório, adaptadores de banco de dados, APIs externas, e configurações de frameworks (Ex: ORM, Web Framework).</file>
      <file path="src/interfaces/">Camada de apresentação (Ex: controllers REST, GraphQL resolvers) ou interfaces externas (Ex: CLI, Workers). Recebe requisições e as traduz para a camada de aplicação.</file>
      <file path="src/shared/">Módulos utility, DTOs (Data Transfer Objects), configurações globais, tratamento de exceções customizado.</file>
      <file path="tests/">Testes em todas as camadas (unitários, integração, e2e).</file>
      <file path="docs/architecture_decision_records.md">Documentação das decisões arquiteturais tomadas durante a refatoração, com justificativas.</file>
    </project_structure>
    <components_specification>
      <component name="Casos de Uso (Use Cases)">
        Responsabilidade: Orquestrar a lógica de negócio específica.
        Inputs: Data Transfer Objects (DTOs) específicos para cada caso de uso.
        Outputs: DTOs ou entidades de domínio.
        Comportamento Esperado: Deve ser independente de qualquer framework ou tecnologia externa. Coordenar serviços de domínio e repositórios. Lidar com transações de forma atômica.
      </component>
      <component name="Repositórios">
        Responsabilidade: Abstrair a persistência de dados.
        Inputs: Entidades de domínio.
        Outputs: Entidades de domínio, coleções de entidades ou null.
        Comportamento Esperado: Implementar as interfaces definidas na camada de domínio. Não deve conter lógica de negócio. Deve ser capaz de interagir com diferentes tecnologias de banco de dados (relacionais, NoSQL) através de adaptadores.
      </component>
      <component name="Serviços de Domínio">
        Responsabilidade: Encapsular lógica de negócio complexa que envolve múltiplas entidades ou agregações, mas que não pertence a nenhuma entidade específica.
        Inputs: Entidades do domínio.
        Outputs: Entidades do domínio ou resultados de operações.
        Comportamento Esperado: Orquestrar operações de domínio, validando o estado das entidades e garantindo invariantes do negócio.
      </component>
      <component name="Controllers/Resolvers">
        Responsabilidade: Receber requisições HTTP (ou outros protocolos), validar inputs básicos, chamar o caso de uso apropriado e formatar a resposta.
        Inputs: Requisições HTTP (JSON, Query Params, Path Params).
        Outputs: Respostas HTTP (JSON, Status Codes).
        Comportamento Esperado: Ser o mais "magro" possível (Thin Controller). Não deve conter lógica de negócio. Deve acionar os casos de uso da camada de aplicação e lidar com a serialização/deserialização.
      </component>
    </components_specification>
    <core_logic>
      <description>O sistema gerencia um catálogo de produtos e pedidos. A lógica de negócio envolve criação, atualização e exclusão de produtos, gerenciamento de estoque, e processamento de pedidos incluindo validação de pagamento e atualização de status.</description>
      <rules>
        <rule>Um produto não pode ter estoque negativo.</rule>
        <rule>Um pedido só pode ser criado se todos os produtos estiverem em estoque suficiente.</rule>
        <rule>O status de um pedido é "Processando" após a criação e "Concluído" após a confirmação de pagamento e despacho.</rule>
        <rule>Ações de estoque (adição/remoção) devem ser auditadas com data e nome do usuário.</rule>
      </rules>
    </core_logic>
  </task>
  <error_handling_pattern>
    <philosophy>Erros são valores explícitos, não exceções para controle de fluxo. Nenhum erro deve ser silenciado. Tratamento de exceções é reservado para falhas inesperadas de infraestrutura ou bugs de programação.</philosophy>
    <rules>
      <rule id="ERR1">Funções que podem falhar devem retornar um tipo `Result` ou `Either` (Ex: `Result<TValue, TError>`), sendo o erro um objeto tipado e descritivo.</rule>
      <rule id="ERR2">Erros de validação de negócio ou de entrada devem ser capturados e retornados de forma padronizada (Ex: lista de erros específicos) da camada de aplicação para a interface.</rule>
      <rule id="ERR3">Exceções de runtime (NPE, divisão por zero, falha de conexão DB) devem ser capturadas na camada de infraestrutura e remapeadas para erros de domínio ou exceções controladas, registradas e, em último caso, propagadas como um erro genérico HTTP 500.</rule>
    </rules>
    <few_shot_error_examples>
      <example label="Tratamento de Validação de Input">
        <before comment="PROIBIDO — Exceções de controle de fluxo de validação">
          function createUser(data) {
            if (!data.name) throw new Error('Name required');
            if (data.age < 18) throw new Error('Underage');
            // ...
          }
        </before>
        <after comment="CORRETO — Retorno de objeto de resultado com erros explícitos">
          function createUser(data): Result<User, ValidationError[]> {
            const errors: ValidationError[] = [];
            if (!data.name) errors.push({ field: 'name', message: 'Name required' });
            if (data.age < 18) errors.push({ field: 'age', message: 'Underage' });
            if (errors.length > 0) return { success: false, errors };
            // ... lógica de criação do usuário
            return { success: true, value: newUser };
          }
        </after>
      </example>
    </few_shot_error_examples>
    <validation>Confirme: Em nenhuma camada de lógica de negócio (`domain`, `application`) é utilizado `throw` para validações ou erros esperados. Todo erro é um valor explícito no retorno da função.</validation>
  </error_handling_pattern>
  <constraints>
    <rule>A refatoração NÃO pode introduzir dependências cíclicas entre módulos ou camadas.</rule>
    <rule>Toda nova funcionalidade ou refatoração DEVE ser acompanhada por testes unitários e de integração relevantes.</rule>
    <rule>A camada de Domain (domínio) DEVE ser agnóstica a qualquer framework, biblioteca de UI, ou tecnologia de persistência.</rule>
    <rule>Não introduzir complexidade desnecessária; focar na solução mais simples que atenda aos requisitos de escalabilidade e manutenibilidade.</rule>
    <rule>A migração do código existente deve ser incremental, minimizando o risco e possibilitando deploys menores e mais frequentes.</rule>
  </constraints>
  <expected_output>
    <format>
      A resposta deve ser estruturada como um plano de refatoração detalhado, dividido em seções claras:
      1. Análise do Código Atual e Identificação de Débitos Técnicos (Baseado no "vibe coding").
      2. Proposta de Arquitetura-Alvo (Ex: Diagrama de camadas e justificativa).
      3. Plano de Ação Detalhado (Passos incrementais para a refatoração e migração).
      4. Diretrizes de Codificação (Padrões, testes, tratamento de erros, documentação).
      5. Recomendações de Ferramentas e Tecnologias.
      6. Um exemplo de código refatorado para um módulo crítico, mostrando a aplicação da nova arquitetura.
      O output final deve ser um documento técnico completo e profissional, pronto para ser apresentado a uma equipe de desenvolvimento.
    </format>
    <quality_bar>
      - Clareza e objetividade na linguagem.
      - Abrangência: todas as áreas do projeto devem ser contempladas na análise e plano.
      - Aderência aos princípios de SOLID, Clean Architecture e DDD.
      - Viabilidade técnica: as propostas devem ser implementáveis no contexto de uma equipe de desenvolvimento.
      - Justificativas sólidas para cada decisão arquitetural e técnica.
      - O código de exemplo deve ser funcional, demonstrar boas práticas e ser facilmente compreendido.
    </quality_bar>
  </expected_output>
</prompt>
```